#+EXPORT_FILE_NAME: 2019-04-09-ecdsa
#+OPTIONS: toc:nil
#+OPTIONS: -:nil

:FRONTMATTER:
---
layout: post
title:  "ELI5: Cryptography - ECDSA"
date:   2019-04-09 08:07:28 +0200
tags: [cryptography ecdsa discrete logarithm eli5]
---
:END:

* Overview

#+begin_src txt
  "If you can't explain it simply, you don't understand it well enough" - Einstein
#+end_src

Elliptic curve cryptography ([[https://en.wikipedia.org/wiki/Elliptic-curve_cryptography][ECC]]) and digital signature algorithm ([[https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm][ECDSA]]) are more complex than RSA or ElGamal but I will try my best to hide the hairy math and the implementation details.

Here is the ELI5 version in 18 lines of [[http://www.sagemath.org][SageMath]] / Python code. I use Sage because it provides elliptic curves as first-class citizens (`FiniteField` and `EllipticCurve`) and we can take multiplication operation for granted.

#+begin_src sage -n :session ecdsa-overview :exports output
  p = 103
  F = FiniteField(p)
  E = EllipticCurve(F, [0, 7])
  G = E([97, 10])
  n = G.order()
  k = randint(2, n)
  P = k * G
  m = 6
  t = randint(2, n)
  R = t * G
  r = mod(R[0], n)
  s = mod(inverse_mod(t, n) * (m + r * k), n)
  inv_s = inverse_mod(int(s), n)
  u = mod(m * inv_s, n)
  v = mod(r * inv_s, n)
  F = int(u) * G + int(v) * P
  f = mod(F[0], n)
  print "YOU ARE A CRYPTOSTAR!" if r == f else "YOU SUCK!"
#+end_src

#+RESULTS:
: YOU ARE A CRYPTOSTAR!

Besides lines #7, #10 and #16 that involves multiplication between a scalar and a point on elliptic curve, everything else is just modular arithmetic and two [[https://en.wikipedia.org/wiki/Multiplicative_inverse][multiplicative inverse]] calculations (line #12 and #13)

Please keep reading if you want line by line explanations and a few elliptic curve graphs.

* Basics

- What the heck is an elliptic curve?
- It is just a simple equation of this form `y2 = x3 + ax + b`.
- Why it is so special?
- Because it has one interesting operation: addition. Adding two points on the curve will result a third point also on the curve (aka closure). Multiplication is particular case of addition, adding the same point to itself `k` times.
- And how does it looks like?
- Well, I am afraid you won't like the graph because elliptic curves defined over finite fields get cut off and are not intelligible to humans eye

But here it is anyway: `a = 0; b = 7` and prime number is `103`.

#+begin_src sage :session ec1 :file ../assets/ec1.png :exports both
E = EllipticCurve(FiniteField(103), [0, 7])
E.plot()
#+end_src

#+RESULTS:
[[file:../assets/ec1.png]]

Not pretty huh? lets define the same elliptic curve over real numbers and the graph starts to make little sense.

#+begin_src sage :session ec2 :file ../assets/ec2.png :exports both
E = EllipticCurve([0, 7])
E.plot()
#+end_src

#+RESULTS:
[[file:../assets/ec2.png]]

* Elliptic curve multiplication trapdoor

First thing first, let's define the elliptic curve parameters and notations:

#+begin_src sage -n :session ecdsa
  p = 103
  F = FiniteField(p)
  E = EllipticCurve(F, [0, 7])
  G = E([97, 10])
  n = G.order()
#+end_src

#+RESULTS:

Variable notations:

- uppercase letter - elements of the elliptic curve like finite fields (F), elliptic curve itself (E) or point on elliptic curve (G)
- lowercase letter - scalar value like the secret key (k)

Domain parameters:

- p - prime number
- F - finite field
- 0,7 - coefficients for elliptic curve
- E - elliptic curve
- G - point generator
- n - order (the number of points) of the cyclic subgroup generated by `G`

Now, it's time to generate the secret key `k` and calculate the public key `P` using the trapdoor function called Elliptic Curve Discrete Logarithm Problem (ECDLP).

This is the bread and the butter of elliptic curve cryptography, given the generator `G` and public key `P' it is infeasible to calculate the secret key `k`, hence the [[https://en.wikipedia.org/wiki/Trapdoor_function][trapdoor]]

#+begin_src sage +n :session ecdsa
  k = randint(2, n)
  P = k * G
#+end_src

#+RESULTS:

If you are curious how elliptic curve point `P` looks like then it is nothing than a Cartesian (x,y) coordinate:

#+begin_src sage :session ecdsa :exports both
  P
#+end_src

#+RESULTS:
: (35 : 31 : 1)

* Signature

Let's sign the message `m` and for this we need to generate a random integer `t` of order `n` and calculate the `R` point on elliptic curve.

#+begin_src sage +n :session ecdsa
  m = 6
  t = randint(2, n)
  R = t * G
  r = mod(R[0], n)
  s = mod(inverse_mod(t, n) * (m + r * k), n)
#+end_src

#+RESULTS:

The signature itself has two numbers `r` and `s` that are sent to third-party for verification:
- r - the `x` coordinate of point `R`
- s - is calculated with `s = (m + r*k) / t` but we use multiplication with inverse instead of division.

And this is how our signature looks like:

#+begin_src sage :session ecdsa :exports both
  [r, s]
#+end_src

#+RESULTS:
: [50, 95]

* Verification

Given the signature `r, s` above and `G, P, r and n` that are public information we need to calculate the equation `F = u*G + v*P` where `u = m/s` and `v = r/s`.

The signature is valid if `R.x == F.x` is true, in other words the `x` coordinates are the same.

#+begin_src sage +n :session ecdsa :exports output
  inv_s = inverse_mod(int(s), n)
  u = mod(m * inv_s, n)
  v = mod(r * inv_s, n)
  F = int(u) * G + int(v) * P
  f = mod(F[0], n)
  print "YOU ARE A CRYPTOSTAR!" if r == f else "YOU SUCK!"
#+end_src

#+RESULTS:
: YOU ARE A CRYPTOSTAR!

* Intuition

Remember that uppercase letters are points on elliptic curve, lowercase are scalars:

#+begin_src sage -n
  R == u*G + v*P
  R == u*G + v*k*P
  R == m/s * G + r/s * k*G
  R == m/s * G + r*k/s * G
  R == (m + r*k)/s * G
  R == (m + r*k)/((m + r*k)/t) * G
#+end_src

As always we will do the math backwards:

1. start with the equation of signature verification and substitute public key `P`
2. substitute `u` and `v`
3. multiplication is commutative and we can put `r` and `k` together
4. extract `G` and `s` as factors
5. substitute `s`
6. after reduction we are left with `t*G`

And the intuition is valid if the `x` coordinates on both sides of the equation are equal.

#+begin_src sage :session ecdsa :exports output
  print "MAGIC" if R[0] == (int((m + r*k)*t/(m + r*k)) * G)[0] else "ERROR"
#+end_src

#+RESULTS:
: MAGIC
